// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: scene.sql

package repository

import (
	"context"
	"database/sql"
)

const selectSceneList = `-- name: SelectSceneList :many
SELECT
	p.name AS scene,
	m.name AS member,
	c.name AS color,
	s.vocal_max + s.dance_max + s.peformance_max + 430 AS total,
	s.vocal_max,
	s.dance_max,
	s.peformance_max,
	s.expected_value as 期待値,
	s.ssr_plus
FROM
	scenes s
	JOIN photograph p ON s.photograph_id = p.id
	JOIN color_types c ON s.color_type_id = c.id
	JOIN members m ON s.member_id = m.id
ORDER BY
	c.id, s.expected_value desc, total desc
`

type SelectSceneListRow struct {
	Scene         string
	Member        string
	Color         string
	Total         int32
	VocalMax      int32
	DanceMax      int32
	PeformanceMax int32
	期待値           sql.NullString
	SsrPlus       bool
}

func (q *Queries) SelectSceneList(ctx context.Context, db DBTX) ([]SelectSceneListRow, error) {
	rows, err := db.QueryContext(ctx, selectSceneList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectSceneListRow
	for rows.Next() {
		var i SelectSceneListRow
		if err := rows.Scan(
			&i.Scene,
			&i.Member,
			&i.Color,
			&i.Total,
			&i.VocalMax,
			&i.DanceMax,
			&i.PeformanceMax,
			&i.期待値,
			&i.SsrPlus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
