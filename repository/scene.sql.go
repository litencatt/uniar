// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: scene.sql

package repository

import (
	"context"
	"database/sql"
)

const getAllScenes = `-- name: GetAllScenes :many
SELECT
	s.photograph_id,
	s.member_id,
	s.ssr_plus
FROM
	scenes s
`

type GetAllScenesRow struct {
	PhotographID int64
	MemberID     int64
	SsrPlus      int64
}

func (q *Queries) GetAllScenes(ctx context.Context, db DBTX) ([]GetAllScenesRow, error) {
	rows, err := db.QueryContext(ctx, getAllScenes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllScenesRow
	for rows.Next() {
		var i GetAllScenesRow
		if err := rows.Scan(&i.PhotographID, &i.MemberID, &i.SsrPlus); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllScenesWithGroupId = `-- name: GetAllScenesWithGroupId :many
;

SELECT
	s.photograph_id,
	s.member_id,
	s.ssr_plus
FROM
	scenes s
	JOIN members m ON s.member_id = m.id
WHERE
	m.group_id = ?
`

type GetAllScenesWithGroupIdRow struct {
	PhotographID int64
	MemberID     int64
	SsrPlus      int64
}

func (q *Queries) GetAllScenesWithGroupId(ctx context.Context, db DBTX, groupID int64) ([]GetAllScenesWithGroupIdRow, error) {
	rows, err := db.QueryContext(ctx, getAllScenesWithGroupId, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllScenesWithGroupIdRow
	for rows.Next() {
		var i GetAllScenesWithGroupIdRow
		if err := rows.Scan(&i.PhotographID, &i.MemberID, &i.SsrPlus); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScenesWithColor = `-- name: GetScenesWithColor :many
;

SELECT
	s.id,
	p.name AS photograph,
	p.id AS photograph_id,
	p.abbreviation,
	m.name AS member,
	m.id AS member_id,
	c.name AS color,
	s.vocal_max + s.dance_max + s.performance_max + 430 AS total,
	s.vocal_max,
	s.dance_max,
	s.performance_max,
	s.expected_value,
	s.ssr_plus,
	pm.bond_level_curent AS bonds,
	pm.discography_disc_total AS discography
FROM
	scenes s
	JOIN photograph p ON s.photograph_id = p.id
	JOIN color_types c ON s.color_type_id = c.id
	JOIN members m ON s.member_id = m.id
	LEFT OUTER JOIN producer_members pm ON s.member_id = pm.member_id
	LEFT OUTER JOIN producer_scenes ps ON s.photograph_id = ps.photograph_id
		AND s.member_id = ps.member_id
		AND s.ssr_plus = ps.ssr_plus
WHERE
	c.name LIKE ?
	AND m.name LIKE ?
	AND p.name LIKE ?
ORDER BY
	s.expected_value desc, total desc
`

type GetScenesWithColorParams struct {
	Name   string
	Name_2 string
	Name_3 string
}

type GetScenesWithColorRow struct {
	ID             int64
	Photograph     string
	PhotographID   int64
	Abbreviation   string
	Member         string
	MemberID       int64
	Color          string
	Total          int64
	VocalMax       int64
	DanceMax       int64
	PerformanceMax int64
	ExpectedValue  sql.NullString
	SsrPlus        int64
	Bonds          int64
	Discography    int64
}

func (q *Queries) GetScenesWithColor(ctx context.Context, db DBTX, arg GetScenesWithColorParams) ([]GetScenesWithColorRow, error) {
	rows, err := db.QueryContext(ctx, getScenesWithColor, arg.Name, arg.Name_2, arg.Name_3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetScenesWithColorRow
	for rows.Next() {
		var i GetScenesWithColorRow
		if err := rows.Scan(
			&i.ID,
			&i.Photograph,
			&i.PhotographID,
			&i.Abbreviation,
			&i.Member,
			&i.MemberID,
			&i.Color,
			&i.Total,
			&i.VocalMax,
			&i.DanceMax,
			&i.PerformanceMax,
			&i.ExpectedValue,
			&i.SsrPlus,
			&i.Bonds,
			&i.Discography,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScenesWithGroupId = `-- name: GetScenesWithGroupId :many
;


SELECT
	p.id as photograph_id,
	m.id as member_id,
	s.ssr_plus,
	case
		when ps.have = 1 then true
		when ps.have != 1 then false
		when ps.have is NULL then false
	end as ps_have
FROM
	scenes s
	JOIN photograph p ON s.photograph_id = p.id
	JOIN members m ON s.member_id = m.id
	LEFT OUTER JOIN producer_scenes ps
		ON s.photograph_id = ps.photograph_id
		AND s.member_id = ps.member_id
		AND s.ssr_plus = ps.ssr_plus
WHERE
    m.group_id = ?
	AND ps.producer_id = ?
ORDER BY
    p.id,
    m.phase,
    m.first_name
`

type GetScenesWithGroupIdParams struct {
	GroupID    int64
	ProducerID int64
}

type GetScenesWithGroupIdRow struct {
	PhotographID int64
	MemberID     int64
	SsrPlus      int64
	PsHave       interface{}
}

func (q *Queries) GetScenesWithGroupId(ctx context.Context, db DBTX, arg GetScenesWithGroupIdParams) ([]GetScenesWithGroupIdRow, error) {
	rows, err := db.QueryContext(ctx, getScenesWithGroupId, arg.GroupID, arg.ProducerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetScenesWithGroupIdRow
	for rows.Next() {
		var i GetScenesWithGroupIdRow
		if err := rows.Scan(
			&i.PhotographID,
			&i.MemberID,
			&i.SsrPlus,
			&i.PsHave,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const registScene = `-- name: RegistScene :exec
;

INSERT INTO scenes (
	photograph_id,
	member_id,
	color_type_id,
	vocal_max,
	dance_max,
	performance_max,
	center_skill,
	expected_value,
	ssr_plus
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type RegistSceneParams struct {
	PhotographID   int64
	MemberID       int64
	ColorTypeID    int64
	VocalMax       int64
	DanceMax       int64
	PerformanceMax int64
	CenterSkill    sql.NullString
	ExpectedValue  sql.NullString
	SsrPlus        int64
}

func (q *Queries) RegistScene(ctx context.Context, db DBTX, arg RegistSceneParams) error {
	_, err := db.ExecContext(ctx, registScene,
		arg.PhotographID,
		arg.MemberID,
		arg.ColorTypeID,
		arg.VocalMax,
		arg.DanceMax,
		arg.PerformanceMax,
		arg.CenterSkill,
		arg.ExpectedValue,
		arg.SsrPlus,
	)
	return err
}
