// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: query.sql

package repository

import (
	"context"
	"database/sql"
)

const getCollections = `-- name: GetCollections :many
SELECT
	p. ` + "`" + `name` + "`" + ` AS photograph,
	m. ` + "`" + `name` + "`" + ` AS member,
	c.name AS color,
	s.ssr_plus,
	s.expected_value AS expected_value
FROM
	producer_scenes ps
	JOIN photograph p ON ps.photograph_id = p.id
	JOIN members m ON ps.member_id = m.id
	LEFT OUTER JOIN scenes s ON p.id = s.photograph_id
		AND m.id = s.member_id
	JOIN color_types c ON s.color_type_id = c.id
WHERE
	have = 1
	AND expected_value IS NOT NULL
ORDER BY
	s.expected_value DESC
`

type GetCollectionsRow struct {
	Photograph    string
	Member        string
	Color         string
	SsrPlus       bool
	ExpectedValue sql.NullString
}

func (q *Queries) GetCollections(ctx context.Context, db DBTX) ([]GetCollectionsRow, error) {
	rows, err := db.QueryContext(ctx, getCollections)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCollectionsRow
	for rows.Next() {
		var i GetCollectionsRow
		if err := rows.Scan(
			&i.Photograph,
			&i.Member,
			&i.Color,
			&i.SsrPlus,
			&i.ExpectedValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroup = `-- name: GetGroup :many
SELECT id, name, created_at FROM ` + "`" + `groups` + "`" + `
`

func (q *Queries) GetGroup(ctx context.Context, db DBTX) ([]Group, error) {
	rows, err := db.QueryContext(ctx, getGroup)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Group
	for rows.Next() {
		var i Group
		if err := rows.Scan(&i.ID, &i.Name, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembers = `-- name: GetMembers :many
SELECT
	g. ` + "`" + `name` + "`" + ` AS ` + "`" + `group` + "`" + `,
	m.id AS member_id,
	m. ` + "`" + `name` + "`" + `,
	m.phase,
	m.graduated
FROM
	members m
	JOIN ` + "`" + `groups` + "`" + ` g ON m.group_id = g.id
`

type GetMembersRow struct {
	Group     string
	MemberID  int32
	Name      string
	Phase     int32
	Graduated bool
}

func (q *Queries) GetMembers(ctx context.Context, db DBTX) ([]GetMembersRow, error) {
	rows, err := db.QueryContext(ctx, getMembers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMembersRow
	for rows.Next() {
		var i GetMembersRow
		if err := rows.Scan(
			&i.Group,
			&i.MemberID,
			&i.Name,
			&i.Phase,
			&i.Graduated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMusicList = `-- name: GetMusicList :many
SELECT
	l.` + "`" + `name` + "`" + ` AS live,
	m.name AS music,
	c.name AS TYPE,
	m.` + "`" + `length` + "`" + `,
	m.music_bonus AS bonus,
	m.master
FROM
	music m
	JOIN lives l ON m.live_id = l.id
	JOIN color_types c ON m.color_type_id = c.id
ORDER BY
	l.id
`

type GetMusicListRow struct {
	Live   string
	Music  string
	Type   string
	Length int32
	Bonus  bool
	Master int32
}

func (q *Queries) GetMusicList(ctx context.Context, db DBTX) ([]GetMusicListRow, error) {
	rows, err := db.QueryContext(ctx, getMusicList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMusicListRow
	for rows.Next() {
		var i GetMusicListRow
		if err := rows.Scan(
			&i.Live,
			&i.Music,
			&i.Type,
			&i.Length,
			&i.Bonus,
			&i.Master,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScenes = `-- name: GetScenes :many
SELECT
	p.name AS photograph,
	m.name AS member,
	c.name AS color,
	s.vocal_max + s.dance_max + s.peformance_max + 430 AS total,
	s.vocal_max,
	s.dance_max,
	s.peformance_max,
	s.expected_value,
	s.ssr_plus
FROM
	scenes s
	JOIN photograph p ON s.photograph_id = p.id
	JOIN color_types c ON s.color_type_id = c.id
	JOIN members m ON s.member_id = m.id
ORDER BY
	c.id, s.expected_value desc, total desc
`

type GetScenesRow struct {
	Photograph    string
	Member        string
	Color         string
	Total         int32
	VocalMax      int32
	DanceMax      int32
	PeformanceMax int32
	ExpectedValue sql.NullString
	SsrPlus       bool
}

// WHERE
//
//	p.id = 1
func (q *Queries) GetScenes(ctx context.Context, db DBTX) ([]GetScenesRow, error) {
	rows, err := db.QueryContext(ctx, getScenes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetScenesRow
	for rows.Next() {
		var i GetScenesRow
		if err := rows.Scan(
			&i.Photograph,
			&i.Member,
			&i.Color,
			&i.Total,
			&i.VocalMax,
			&i.DanceMax,
			&i.PeformanceMax,
			&i.ExpectedValue,
			&i.SsrPlus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
